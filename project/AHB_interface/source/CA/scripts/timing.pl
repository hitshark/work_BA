#!/usr/bin/perl
#/******************************************************************************
#  file name: timing.pl
#  original author: Tao Li
#  simple description:
#    this file extracts the time information for the output ports of AHB master 
#  interface from the .rpt file which generated by synthesis,then annotate
#  these time information to the AHB interface ports described in SystemC.
#    there are two command line parameters, one is the input file which provides the 
#  source data and is often in the format .rpt(report file generated by synthesis).
#  the other file is the ca_transmit.cpp file, 
#  the perl scripts will make use of the ca_transmit.cpp file to generate
#  the output ta_transmit.cpp file,which is added the delay time information.
#  so,if you want to use this perl scripts to generated a timing accurate 
#  ahb_interface model file with specific time information,make sure that there are
#  two files you must include in your working path:the .rpt file which has the delay
#  information of the AHB master interface output ports and the ca_transmit.cpp. 
 
#  modification history - modifiers, enter your name, affliation and
#  changes you are making here:
# 
#  Modifier Name & Affiliation:
#  Description of Modification:
#
#******************************************************************************/

use warnings;

#-------------------------------------------------------------------------------
# the following codes will extracts the delay information from the .rpt file 
# and store them to the hash data structure varable %signal_delay_hash.
#-------------------------------------------------------------------------------
@argument = @ARGV;
pop @ARGV;
while(<>){
	$ahbo_signal_name = $1 if(/^\s*?Endpoint:\s+(\w+)/);
	if(/^\s*?data arrival time\s+([\d.-]+)/)
	{
		$output_delay = $1;
		$flag++;
		$flag = 0 if($flag == 2);
		$signal_delay_hash{$ahbo_signal_name} = $output_delay if($flag ==1);
	}
}

#-------------------------------------------------------------------------------
# the foreach cycle will find the longest delay of each output ports,
# and store it to the hash data structure varable %result.
#-------------------------------------------------------------------------------
foreach (keys %signal_delay_hash)
{
	if(/^ahbo_HSIZE/)
	{
		$result{"hsize_o"} = $signal_delay_hash{$_} if($result{"hsize_o"} < $signal_delay_hash{$_}); 
	}
	elsif(/^ahbo_HWDATA/)
	{
		$result{"hwdata_o"} = $signal_delay_hash{$_} if($result{"hwdata_o"} < $signal_delay_hash{$_});
	}
	elsif(/^ahbo_HADDR/)
	{
		$result{"haddr_o"} = $signal_delay_hash{$_} if($result{"haddr_o"} < $signal_delay_hash{$_});
	}
	elsif(/^ahbo_HTRANS/)
	{
		$result{"htrans_o"} = $signal_delay_hash{$_} if($result{"htrans_o"} < $signal_delay_hash{$_});
	}
	elsif(/^ahbo_HBUSREQ/)
	{
		$result{"hbusreq_o"} = $signal_delay_hash{$_} if($result{"hbusreq_o"} < $signal_delay_hash{$_});
	}
	elsif(/^ahbo_HBURST/)
	{
		$result{"hburst_o"} = $signal_delay_hash{$_} if($result{"hburst_o"} < $signal_delay_hash{$_});
	}
	elsif(/^ahbo_HLOCK/)
	{
		$result{"hlock_o"} = $signal_delay_hash{$_} if($result{"hlock_o"} < $signal_delay_hash{$_});
	}
	elsif(/^ahbo_HWRITE/)
	{
		$result{"hwrite_o"} = $signal_delay_hash{$_} if($result{"hwrite_o"} < $signal_delay_hash{$_});
	}
	else
	{
		$result{"hprot_o"} = $signal_delay_hash{$_} if($result{"hprot_o"} < $signal_delay_hash{$_});
	}
}

#---------------------------------------------------------------------------------
# in this design,we don't realise the hlock and hprot signal,so it will
# be convenient for the next steps if we delete these two signals from %result.
#---------------------------------------------------------------------------------
foreach (keys %result)
{
	$signal_delay{$_} = $result{$_} if(($_ ne "hlock_o") && ($_ ne "hprot_o"));
}
	
#---------------------------------------------------------------------------------
# in SystemC,the wait() method is used to realise delay,but the delay mechanism
# is different from that in verilog.for example,there are two expressions in verilog:
# 'output port1=#delay_time1 expression';
# 'output port2=#delay_time2 expression'; 
# port1 will be assigned after delay_time1 from now,and port2 will be assigned 
# after delay_time2 from now,not from the moment that port1 is being assigned.
# but in SystemC,when we use wait(delay_time1);wait(delay_time2);the delay_time2
# is calculated from the moment that the first expression is being executed,so this
# is the difference.
# the following codes will sort the signals according to the delay values to 
# make it convenient for the next steps.
#---------------------------------------------------------------------------------
sub by_time_and_name{
	$signal_delay{$a} <=> $signal_delay{$b}
	or
	$a cmp $b
}
@signals_after_sort = sort by_time_and_name keys %signal_delay;
	
#--------------------------------------------------------------------------
# the following codes put the delay time information of output ports
# to the AHB interface which are described by SystemC.
# we use the sc_core::wait(delay_time) method to accomplish it.
#--------------------------------------------------------------------------
 @ARGV = pop @argument;
 open CODES, ">ta_transmit.cpp"
   or die "can't open 'ca_transmit.cpp': $!";
 $state = "";
 while(<>){
	if(m#^\s+?//PERL:RESET:#)
	{
		$state = "reset";
		$reset_flag = 1;
	}
	$reset_flag = 0 if(m#^\s+?//PERL:END RESET:#);
	
	if(m#^\s+?//PERL:BREQ#)
	{
		$state = "bus request";
		$breq_flag = 1;
	}
	$breq_flag = 0 if(m#^\s+?//PERL:END BREQ#);
	
	if(m#^\s+?//PERL:HBUSREQ#)
	{
		$state = "hbusreq";
		$hbusreq_flag = 1;
	}
	$hbusreq_flag = 0 if(m#^\s+?//PERL:END HBUSREQ#);
	
	if(m#^\s+?//PERL:TRAN_ADDR#)
	{
		$state = "tran_addr";
		$tran_addr_flag = 1;
	}
	$tran_addr_flag = 0 if(m#^\s+?//PERL:END TRAN_ADDR#);
	
	if(m#^\s+?//PERL:BUSREQ_ADDR#)
	{
		$state = "busreq_addr";
		$busreq_addr_flag = 1;
	}
	$busreq_addr_flag = 0 if(m#^\s+?//PERL:END BUSREQ_ADDR#);
	
	if(m#^\s+?//PERL:BRQ_TR_ADR#)
	{
		$state = "brq_tr_adr";
		$brq_tr_adr_flag = 1;
	}
	$brq_tr_adr_flag = 0 if(m#^\s+?//PERL:END BRQ_TR_ADR#);
	
	if(m#^\s+?//PERL:WDATA_TR_ADR#)
	{
		$state = "wdata_tr_adr";
		$wdata_tr_adr_flag = 1;
	}
	$wdata_tr_adr_flag = 0 if(m#^\s+?//PERL:END WDATA_TR_ADR#);
	
	if(m#^\s+?//PERL:WDATA_TR_ADR_BRQ#)
	{
		$state = "wdata_tr_adr_brq";
		$wdata_tr_adr_brq_flag = 1;
	}
	$wdata_tr_adr_brq_flag = 0 if(m#^\s+?//PERL:END WDATA_TR_ADR_BRQ#);

	if($state eq "reset")
	{
		if($reset_flag == 0)
		{
			my @temp_signals = @signals_after_sort;
			my $j;
			while(defined(my $i = shift @temp_signals))
			{
				my $delay = $signal_delay{$i}-$signal_delay{$j};
				$j = $i;
				if($i eq "hbusreq_o")
				{
					print CODES "\twait($delay,SC_NS), hbusreq_o=FALSE;\n";
				}
				elsif($i eq "hsize_o")
				{
					print CODES "\twait($delay,SC_NS), hsize_o=WORD;\n";
				}
				elsif($i eq "htrans_o")
				{
					print CODES "\twait($delay,SC_NS), htrans_o=IDLE;\n";
				}
				elsif($i eq "hburst_o")
				{	
					print CODES "\twait($delay,SC_NS), hburst_o=SINGLE;\n";
				}
				elsif($i eq "hwrite_o")
				{
					print CODES "\twait($delay,SC_NS), hwrite_o=READ;\n";
				}
				elsif($i eq "haddr_o")
				{
					print CODES "\twait($delay,SC_NS), haddr_o=DEFAULT_ADDR;\n";
				}
				else
				{
					print CODES "\twait($delay,SC_NS), hwdata_o=DEFAULT_DATA;\n";
				}
			}
			$state = "";
		}
	}
	elsif($state eq "bus request")
	{
		if($breq_flag == 0)
		{
			my @temp_signals = @signals_after_sort;
			my $j;
			while(defined(my $i = shift @temp_signals))
			{
				my $delay = $signal_delay{$i}-$signal_delay{$j};
				if($i eq "hbusreq_o")
				{
					print CODES "\t\t\t\t\tif(t_burst!=INCR)                   	// if burst type is INCR,then\n";
					print CODES "\t\t\t\t\t									   	// it needs asserting hbusreq_o singal until the\n";
					print CODES "\t\t\t\t\t									   	// last transmit starts\n";
					print CODES "\t\t\t\t\t{\n";
					print CODES "\t\t\t\t\t\twait($delay,SC_NS), hbusreq_o=FALSE;\n";
					print CODES "\t\t\t\t\t}\n";
					$j = $i;
				}
				elsif($i eq "hsize_o")
				{
					print CODES "\t\t\t\t\twait($delay,SC_NS), hsize_o=t_size;\n";
					$j = $i;
				}
				elsif($i eq "htrans_o")
				{
					print CODES "\t\t\t\t\twait($delay,SC_NS), htrans_o=NONSEQ;\t\t\t\t\t// transmit type is set to nonsequential\n";
					$j = $i;
				}
				elsif($i eq "hburst_o")
				{	
					print CODES "\t\t\t\t\twait($delay,SC_NS), hburst_o=t_burst;\n";
					$j = $i;
				}
				elsif($i eq "hwrite_o")
				{
					print CODES "\t\t\t\t\tif(t_write==WRITE)                  // read or write\n";
					print CODES "\t\t\t\t\t{\n";
					print CODES "\t\t\t\t\t\twait($delay,SC_NS), hwrite_o=WRITE;\n";
					print CODES "\t\t\t\t\t\tahb_master_state=AHBM_NSEQWR;\n";
					print CODES "\t\t\t\t\t}\n";
					print CODES "\t\t\t\t\telse\n";
					print CODES "\t\t\t\t\t{\n";
					print CODES "\t\t\t\t\t\twait($delay,SC_NS), hwrite_o=READ;\n";
					print CODES "\t\t\t\t\t\tahb_master_state=AHBM_NSEQRD;\n";
					print CODES "\t\t\t\t\t}\n";
					$j = $i;
				}
				elsif($i eq "haddr_o")
				{
					print CODES "\t\t\t\t\twait($delay,SC_NS), haddr_o=temp_addr;\n";
					print CODES "\t\t\t\t\ttemp_addr=update_addr(temp_addr,t_burst,t_size);\n";
					$j = $i;
				}
				else{}
			}
			$state = "";
		}
	}
	elsif($state eq "tran_addr")
	{
		if($tran_addr_flag == 1)
		{
			&my_insert2("htrans_o","haddr_o");
		}
		else
		{
			$state = "";
		}
	}
	elsif($state eq "busreq_addr")
	{
		if($busreq_addr_flag == 1)
		{
			&my_insert2("hbusreq_o","haddr_o");
		}
		else
		{
			$state = "";
		}
	}
	elsif($state eq "brq_tr_adr")
	{
		if($brq_tr_adr_flag == 1)
		{
			&my_insert3("hbusreq_o","htrans_o","haddr_o");
		}
		else
		{
			$state = "";
		}
	}
	elsif($state eq "wdata_tr_adr")
	{
		if($wdata_tr_adr_flag == 1)
		{
			&my_insert3("hwdata_o","htrans_o","haddr_o");
		}
		else
		{
			$state = "";
		}
	}
	elsif($state eq "hbusreq")
	{
		if($hbusreq_flag == 1)
		{
			if(/\s+?hbusreq_o=/)
			{
				s/hbusreq_o/wait($signal_delay{"hbusreq_o"},SC_NS),hbusreq_o/;
				print CODES $_;
			}
		}
		else
		{
			$state = "";
		}
	}
	elsif($state eq "wdata_tr_adr_brq")
	{
		if($wdata_tr_adr_brq_flag == 0)
		{
			my @temp_signals = @signals_after_sort;
			my $j;
			while(defined(my $i = shift @temp_signals))
			{
				my $delay = $signal_delay{$i}-$signal_delay{$j};
				if($i eq "hbusreq_o")
				{
					print CODES "\t\t\t\t\t\t\twait($delay,SC_NS), hbusreq_o=FALSE;\n";
					$j = $i;
				}
				elsif($i eq "htrans_o")
				{
					print CODES "\t\t\t\t\t\t\twait($delay,SC_NS), htrans_o=IDLE;\n";
					$j = $i;
				}
				elsif($i eq "haddr_o")
				{
					print CODES "\t\t\t\t\t\t\twait($delay,SC_NS), haddr_o=DEFAULT_ADDR;\n";
					$j = $i;
				}
				elsif($i eq "hwdata_o")
				{
					print CODES "\t\t\t\t\t\t\twait($delay,SC_NS), hwdata_o=t_wdata[beat_count-1];\n";
					$j = $i;
				}
			}
			$state = "";
		}
	}
	else
	{
		print CODES $_;
	}
}
		
#----------------------------------------------------------------------------------
# help functions.used to handle the assignment expression.
# the parameters are the output signals,the order is just like that in the codes.
# you can call the function like &my_insertx(output signal 1,...,output signal x)
# it will only handle the output related signals,
# and it has local varibles $insertx_temp_y which are used to store the results,
# maybe we should change the access right of $insertx_temp_y to global.
#   these help functions will print the assignment expressions with delay time
# information of output ports to the result file according to the sequence of
# the values of output ports assignment delay.   
#----------------------------------------------------------------------------------

sub my_insert2{
	print "WARNING! function my_insert2 should get two parameters!\n" if(@_ != 2);
	my($m,$n) = @_;
	$insert2_temp_m;
	$insert2_temp_n;
	if(/^\s+?$m=/)
	{
		$insert2_temp_m = $_;
	}
	if(/^\s+?$n=/)
	{
		$insert2_temp_n = $_;
		if($signal_delay{$m} < $signal_delay{$n})
		{
			my $delay = $signal_delay{$n} - $signal_delay{$m};
			$insert2_temp_m =~ s/$m/wait($signal_delay{$m},SC_NS), $m/;
			$insert2_temp_n =~ s/$n/wait($delay,SC_NS), $n/;
			print CODES $insert2_temp_m;
			print CODES $insert2_temp_n;
		}
		else
		{
			my $delay = $signal_delay{$n} - $signal_delay{$m};
			$insert2_temp_m =~ s/$m/wait($signal_delay{$m},SC_NS), $m/;
			$insert2_temp_n =~ s/$n/wait($delay,SC_NS), $n/;
			print CODES $insert2_temp_m;
			print CODES $insert2_temp_n;
		}
	}
}

sub my_insert3{
print "WARNING! function my_insert2 should get three parameters!\n" if(@_ != 3);
my($m,$n,$p) = @_;
$insert3_temp_m;
$insert3_temp_n;
$insert3_temp_p;
if(/^\s+?$m=/)
{
	$insert3_temp_m = $_;
}
if(/^\s+?$n=/)
{
	$insert3_temp_n = $_;
}
if(/^\s+?$p=/)
{
	$insert3_temp_p = $_;
	if($signal_delay{$m} < $signal_delay{$n} && $signal_delay{$n} < $signal_delay{$p})
	{
		my $delay1 = $signal_delay{$n} - $signal_delay{$m};
		my $delay2 = $signal_delay{$p} - $signal_delay{$n};
		$insert3_temp_m =~ s/$m/wait($signal_delay{$m},SC_NS),$m/;
		$insert3_temp_n =~ s/$n/wait($delay1,SC_NS),$n/;
		$insert3_temp_p =~ s/$p/wait($delay2,SC_NS),$p/;
		print CODES $insert3_temp_m; 
		print CODES $insert3_temp_n;
		print CODES $insert3_temp_p;
	}
	elsif($signal_delay{$m} < $signal_delay{$p} && $signal_delay{$p} < $signal_delay{$n})
	{
		my $delay1 = $signal_delay{$p} - $signal_delay{$m};
		my $delay2 = $signal_delay{$n} - $signal_delay{$p};
		$insert3_temp_m =~ s/$m/wait($signal_delay{$m},SC_NS),$m/;
		$insert3_temp_n =~ s/$n/wait($delay2,SC_NS),$n/;
		$insert3_temp_p =~ s/$p/wait($delay1,SC_NS),$p/;
		print CODES $insert3_temp_m; 
		print CODES $insert3_temp_p;
		print CODES $insert3_temp_n;
	}
	elsif($signal_delay{$p} < $signal_delay{$n} && $signal_delay{$n} < $signal_delay{$m})
	{
		my $delay1 = $signal_delay{$n} - $signal_delay{$p};
		my $delay2 = $signal_delay{$m} - $signal_delay{$n};
		$insert3_temp_m =~ s/$m/wait($delay2,SC_NS),$m/;
		$insert3_temp_n =~ s/$n/wait($delay1,SC_NS),$n/;
		$insert3_temp_p =~ s/$p/wait($signal_delay{$p},SC_NS),$p/;
		print CODES $insert3_temp_p; 
		print CODES $insert3_temp_n;
		print CODES $insert3_temp_m;
	}
	elsif($signal_delay{$p} < $signal_delay{$m} && $signal_delay{$m} < $signal_delay{$n})
	{
		my $delay1 = $signal_delay{$m} - $signal_delay{$p};
		my $delay2 = $signal_delay{$n} - $signal_delay{$m};
		$insert3_temp_m =~ s/$m/wait($delay1,SC_NS),$m/;
		$insert3_temp_n =~ s/$n/wait($delay2,SC_NS),$n/;
		$insert3_temp_p =~ s/$p/wait($signal_delay{$p},SC_NS),$p/;
		print CODES $insert3_temp_p; 
		print CODES $insert3_temp_m;
		print CODES $insert3_temp_n;
	}
	elsif($signal_delay{$n} < $signal_delay{$p} && $signal_delay{$p} < $signal_delay{$m})
	{
		my $delay1 = $signal_delay{$p} - $signal_delay{$n};
		my $delay2 = $signal_delay{$m} - $signal_delay{$p};
		$insert3_temp_m =~ s/$m/wait($delay2,SC_NS),$m/;
		$insert3_temp_n =~ s/$n/wait($signal_delay{$n},SC_NS),$n/;
		$insert3_temp_p =~ s/$p/wait($delay1,SC_NS),$p/;
		print CODES $insert3_temp_n; 
		print CODES $insert3_temp_p;
		print CODES $insert3_temp_m;
	}
	else
	{
		my $delay1 = $signal_delay{$m} - $signal_delay{$n};
		my $delay2 = $signal_delay{$p} - $signal_delay{$m};
		$insert3_temp_m =~ s/$m/wait($delay1,SC_NS),$m/;
		$insert3_temp_n =~ s/$n/wait($signal_delay{$n},SC_NS),$n/;
		$insert3_temp_p =~ s/$p/wait($delay2,SC_NS),$p/;
		print CODES $insert3_temp_n; 
		print CODES $insert3_temp_m;
		print CODES $insert3_temp_p;
	}
}
}
			

		